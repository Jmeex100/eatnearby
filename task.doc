invalid payment session.  lets fix paypal error what i have on my codes is   {% extends "base.html" %}

# payments/urls.py
from django.urls import path
from . import views

app_name = 'payments'

urlpatterns = [
    path('checkout/', views.checkout, name='checkout'),
    path('airtel-payment-process/', views.airtel_payment_process, name='airtel_payment_process'),
    path('zamtel-payment-process/', views.zamtel_payment_process, name='zamtel_payment_process'),
    path('mtn-payment-process/', views.mtn_payment_process, name='mtn_payment_process'),  # Add this
    path('payment-success/<int:delivery_id>/', views.payment_success, name='payment_success'),
    path('payment-done/', views.payment_done, name='payment_done'),
    path('payment-cancelled/', views.payment_cancelled, name='payment_cancelled'),
    path('order-history/', views.order_history, name='order_history'),
    path('reorder/<int:payment_id>/', views.reorder, name='reorder'),
    path('mtn-callback/', views.mtn_callback, name='mtn_callback'),
]

{% block title %}PayPal Checkout{% endblock %}
{% comment %} /home/surecode/Documents/GitHub/django/eatnearby/payments/templates/payments/paypal_checkout.html {% endcomment %}
{% block content %}
<div class="min-h-screen bg-gray-100 pt-16 pb-8">
    <div class="max-w-3xl mx-auto bg-white shadow-lg rounded-lg p-8 text-center">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">Proceeding to PayPal</h1>
        <p class="text-gray-700 mb-4">You will be redirected to PayPal to complete your payment of K{{ cart.total|floatformat:2 }}.</p>
        {{ form.render }}
        <script>
            document.forms[0].submit();
        </script>
        <a href="{% url 'payments:checkout' %}" class="mt-6 inline-block bg-red-600 text-white py-3 px-6 rounded-lg hover:bg-red-700 transition duration-300">Cancel Payment</a>
    </div>
</div>
{% endblock %}  {% extends "base.html" %}
{% block title %}Order Confirmation{% endblock %}
{% comment %} /home/surecode/Documents/GitHub/django/eatnearby/payments/templates/payments/success.html {% endcomment %}
{% block content %}
<div class="min-h-screen bg-gray-100 pt-16 pb-8">
    <!-- PC View (Hidden on Mobile) -->
    <div class="hidden md:block">
        <div class="max-w-3xl mx-auto bg-white shadow-lg rounded-lg p-8 text-center">
            {% if is_pending %}
                <h1 class="text-3xl font-bold text-yellow-600 mb-6">Order Payment Pending</h1>
                <p class="text-gray-700 mb-4 text-lg">Your PayPal payment is being processed. You'll receive a confirmation soon.</p>
            {% else %}
                <h1 class="text-3xl font-bold text-green-600 mb-6">Order Placed Successfully!</h1>
                <p class="text-gray-700 mb-4 text-lg">Thank you for your order. Here are the details:</p>
            {% endif %}
            {% if messages %}
                {% for message in messages %}
                    <p class="{% if message.tags == 'error' %}text-red-600{% else %}text-green-600{% endif %} mb-4">{{ message }}</p>
                {% endfor %}
            {% endif %}
            <div class="space-y-4 text-left">
                <p><strong>Payment ID:</strong> {{ payment_history.id|default:"Pending" }}</p>
                <p><strong>Ordered By:</strong> {{ delivery_info.user.username }}</p>
                <p><strong>Delivery Location:</strong> {{ delivery_info.address|default:delivery_info.get_predefined_address_display }}</p>
                <p><strong>Payment Method:</strong> {{ delivery_info.get_payment_method_display }}</p>
                <p><strong>Phone Number:</strong> {{ delivery_info.phone_number }}</p>
                {% if delivery_info.secondary_phone_number %}
                    <p><strong>Secondary Phone:</strong> {{ delivery_info.secondary_phone_number }}</p>
                {% endif %}
                <p><strong>Status:</strong> {{ delivery_info.get_delivery_status_display }}</p>
                
                <!-- Status Feedback -->
                {% if is_pending %}
                    <p class="text-yellow-600 font-semibold">Your PayPal payment is being processed. Please wait for confirmation.</p>
                {% elif delivery_info.delivery_status == 'pending' %}
                    <p class="text-yellow-600 font-semibold">Your order is awaiting staff assignment. Please wait.</p>
                {% elif delivery_info.delivery_status == 'in_progress' %}
                    <p class="text-blue-600 font-semibold">Your order is being processed. Please confirm receipt below.</p>
                {% elif delivery_info.delivery_status == 'completed' %}
                    <p class="text-green-600 font-semibold">Your order has been confirmed and completed.</p>
                {% elif delivery_info.delivery_status == 'cancelled' %}
                    <p class="text-red-600 font-semibold">Your order has been cancelled.</p>
                {% endif %}
                
                <!-- Product Information -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Ordered Items:</h3>
                    <div class="space-y-2">
                        {% if payment_history %}
                            {% for item in payment_history.items %}
                                <div class="flex justify-between">
                                    <span>{{ item.name }} (x{{ item.quantity }})</span>
                                    <span>K{{ item.subtotal|floatformat:2 }}</span>
                                </div>
                            {% endfor %}
                        {% else %}
                            {% for item in cart.cartitem_set.all %}
                                <div class="flex justify-between">
                                    <span>{{ item.get_product.name }} (x{{ item.quantity }})</span>
                                    <span>K{{ item.subtotal|floatformat:2 }}</span>
                                </div>
                            {% endfor %}
                        {% endif %}
                    </div>
                </div>
                <p><strong>Total:</strong> K{{ cart.total|floatformat:2 }}</p>
            </div>
            {% if delivery_info.delivery_status == 'in_progress' and not payment_history %}
                <form method="post" class="mt-6">
                    {% csrf_token %}
                    <button type="submit" class="bg-green-600 text-white py-3 px-6 rounded-lg hover:bg-green-700 transition duration-300">Confirm Order Receipt</button>
                </form>
            {% endif %}
            <a href="{% url 'cart:cart_view' %}" class="mt-6 inline-block bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 transition duration-300">Back to Cart</a>
        </div>
    </div>

    <!-- Mobile View (Hidden on PC) -->
    <div class="md:hidden">
        <div class="bg-white shadow-lg rounded-lg p-4 mx-2 text-center">
            {% if is_pending %}
                <h1 class="text-2xl font-bold text-yellow-600 mb-4">Order Payment Pending</h1>
                <p class="text-gray-700 mb-4 text-sm">Your PayPal payment is being processed. You'll receive a confirmation soon.</p>
            {% else %}
                <h1 class="text-2xl font-bold text-green-600 mb-4">Order Placed!</h1>
                <p class="text-gray-700 mb-4 text-sm">Thank you for your order. Details:</p>
            {% endif %}
            {% if messages %}
                {% for message in messages %}
                    <p class="{% if message.tags == 'error' %}text-red-600{% else %}text-green-600{% endif %} mb-4 text-sm">{{ message }}</p>
                {% endfor %}
            {% endif %}
            <div class="space-y-2 text-left text-sm">
                <p><strong>Payment ID:</strong> {{ payment_history.id|default:"Pending" }}</p>
                <p><strong>Ordered By:</strong> {{ delivery_info.user.username }}</p>
                <p><strong>Location:</strong> {{ delivery_info.address|default:delivery_info.get_predefined_address_display }}</p>
                <p><strong>Payment:</strong> {{ delivery_info.get_payment_method_display }}</p>
                <p><strong>Phone:</strong> {{ delivery_info.phone_number }}</p>
                {% if delivery_info.secondary_phone_number %}
                    <p><strong>Secondary:</strong> {{ delivery_info.secondary_phone_number }}</p>
                {% endif %}
                <p><strong>Status:</strong> {{ delivery_info.get_delivery_status_display }}</p>
                
                <!-- Status Feedback -->
                {% if is_pending %}
                    <p class="text-yellow-600 font-semibold">Your PayPal payment is being processed. Please wait for confirmation.</p>
                {% elif delivery_info.delivery_status == 'pending' %}
                    <p class="text-yellow-600 font-semibold">Your order is awaiting staff assignment. Please wait.</p>
                {% elif delivery_info.delivery_status == 'in_progress' %}
                    <p class="text-blue-600 font-semibold">Your order is being processed. Please confirm receipt below.</p>
                {% elif delivery_info.delivery_status == 'completed' %}
                    <p class="text-green-600 font-semibold">Your order has been confirmed and completed.</p>
                {% elif delivery_info.delivery_status == 'cancelled' %}
                    <p class="text-red-600 font-semibold">Your order has been cancelled.</p>
                {% endif %}
                
                <!-- Product Information -->
                <div>
                    <h3 class="text-base font-semibold text-gray-700 mb-1">Ordered Items:</h3>
                    <div class="space-y-1">
                        {% if payment_history %}
                            {% for item in payment_history.items %}
                                <div class="flex justify-between">
                                    <span>{{ item.name }} (x{{ item.quantity }})</span>
                                    <span>K{{ item.subtotal|floatformat:2 }}</span>
                                </div>
                            {% endfor %}
                        {% else %}
                            {% for item in cart.cartitem_set.all %}
                                <div class="flex justify-between">
                                    <span>{{ item.get_product.name }} (x{{ item.quantity }})</span>
                                    <span>K{{ item.subtotal|floatformat:2 }}</span>
                                </div>
                            {% endfor %}
                        {% endif %}
                    </div>
                </div>
                <p><strong>Total:</strong> K{{ cart.total|floatformat:2 }}</p>
            </div>
            {% if delivery_info.delivery_status == 'in_progress' and not payment_history %}
                <form method="post" class="mt-4">
                    {% csrf_token %}
                    <button type="submit" class="bg-green-600 text-white py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300">Confirm Order Receipt</button>
                </form>
            {% endif %}
            <a href="{% url 'cart:cart_view' %}" class="mt-4 inline-block bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">Back to Cart</a>
        </div>
    </div>
</div>
{% endblock %}  from django.conf import settings
from paypal.standard.forms import PayPalPaymentsForm
import uuid
from django.core.exceptions import ImproperlyConfigured
# /home/surecode/Documents/GitHub/django/eatnearby/payments/cards/paypal.py
def initiate_paypal_payment(request, cart, delivery_info, total_usd):
    """
    Initiate a PayPal payment for the given cart and delivery info.

    Args:
        request: The HTTP request object.
        cart: The user's cart object (Cart model instance).
        delivery_info: The DeliveryInfo instance tied to the order.
        total_usd: The total amount in USD (float).

    Returns:
        PayPalPaymentsForm: A configured PayPal form ready to render.

    Raises:
        ImproperlyConfigured: If required PayPal settings are missing.
    """
    # Validate required settings
    if not hasattr(settings, 'PAYPAL_RECEIVER_EMAIL'):
        raise ImproperlyConfigured("PAYPAL_RECEIVER_EMAIL must be set in settings.py")

    paypal_dict = {
        "business": settings.PAYPAL_RECEIVER_EMAIL,
        "amount": f"{total_usd:.2f}",  # Ensure 2 decimal places
        "item_name": f"Order for {request.user.username}",
        "invoice": str(uuid.uuid4()),
        "currency_code": "USD",
        "notify_url": request.build_absolute_uri('/paypal/'),
        "return_url": request.build_absolute_uri('/payments/payment-done/'),
        "cancel_return": request.build_absolute_uri('/payments/payment-cancelled/'),
        "custom": str(delivery_info.id),  # Pass delivery_info ID for IPN
    }

    # Optional PayPal settings from settings.py
    if hasattr(settings, 'PAYPAL_TEST') and settings.PAYPAL_TEST:
        paypal_dict["test_ipn"] = "1"  # Enable sandbox mode if PAYPAL_TEST is True

    form = PayPalPaymentsForm(initial=paypal_dict)
    return form

def verify_paypal_payment(request):
    """
    Placeholder for verifying PayPal payment (e.g., via IPN).
    To be implemented if needed for custom IPN handling.
    """
    # Add logic here if you want custom IPN processing beyond django-paypal's default
    pass     import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.contrib import messages

from cart.models import Cart, CartItem
from auths.models import FastFood, Food, Drink
from .models import DeliveryInfo, PaymentHistory
from staffs.models import StaffAssignment, Notification
from staffs.staffs_assignments import pick_staff_for_point

# Payment integrations
from .cards.paypal import initiate_paypal_payment
from .cards.pesapal import initiate_pesapal_payment
from .cards.stripe import initiate_stripe_payment, verify_stripe_payment
from .mobile.airtel import initiate_airtel_payment
from .mobile.zamtel import initiate_zamtel_payment
from .mobile.mtn import initiate_mtn_payment
from .mobile.twilio_utils import send_sms

logger = logging.getLogger(__name__)

@login_required
def checkout(request):
    try:
        cart = Cart.objects.get(user=request.user)
        if not cart.cartitem_set.exists():
            messages.warning(request, "Your cart is empty. Add items before checking out.")
            return redirect('cart:cart_view')
    except Cart.DoesNotExist:
        messages.error(request, "No cart found. Please add items to your cart.")
        return redirect('cart:cart_view')

    EXCHANGE_RATE = 28.638  # 1 USD = 28.638 ZMW (March 2025)
    total_usd = float(cart.total()) / EXCHANGE_RATE
    total_zmw = float(cart.total())

    context = {
        'cart': cart,
        'delivery_points': DeliveryInfo.DELIVERY_POINTS,
        'payment_methods': DeliveryInfo.PAYMENT_METHODS,
        'mobile_money_providers': DeliveryInfo.MOBILE_MONEY_PROVIDERS,
        'card_providers': DeliveryInfo.CARD_PROVIDERS,
        'total_usd': total_usd,
        'total_zmw': total_zmw,
    }

    if request.method == 'POST':
        address = request.POST.get('address', '')
        predefined_address = request.POST.get('predefined_address', '')
        payment_method = request.POST.get('payment_method', 'cash')
        payment_provider = request.POST.get('payment_provider', '')
        phone_number = request.POST.get('phone_number', '')
        secondary_phone_number = request.POST.get('secondary_phone_number', '')

        if not phone_number:
            messages.error(request, "Phone number is required.")
            return render(request, 'payments/checkout.html', context)
        if payment_method in ('mobile_money', 'card') and not payment_provider:
            messages.error(request, f"Select a provider for {payment_method.replace('_', ' ').title()}.")
            return render(request, 'payments/checkout.html', context)
        if not predefined_address:
            messages.error(request, "Please select a delivery point.")
            return render(request, 'payments/checkout.html', context)

        delivery_info = DeliveryInfo.objects.create(
            user=request.user,
            cart=cart,
            address=address if not predefined_address else None,
            predefined_address=predefined_address,
            payment_method=payment_method,
            payment_provider=payment_provider or None,
            phone_number=phone_number,
            secondary_phone_number=secondary_phone_number or None,
        )
        logger.info(f"Created DeliveryInfo {delivery_info.id} with status {delivery_info.delivery_status}")

        staff = pick_staff_for_point(delivery_info.predefined_address)
        if staff:
            StaffAssignment.objects.create(staff=staff, delivery=delivery_info)
            Notification.objects.create(
                recipient=staff,
                message=f"New delivery at {delivery_info.get_predefined_address_display()} (Order ID: {delivery_info.id})",
                related_delivery=delivery_info,
                notification_type='new_order'
            )
            logger.info(f"Assigned delivery {delivery_info.id} to staff {staff.id}")
        else:
            logger.warning(f"No staff available for delivery {delivery_info.id}")

        # Handle card payments
        if payment_method == 'card':
            try:
                if payment_provider == 'paypal':
                    form = initiate_paypal_payment(request, cart, delivery_info, total_usd)
                    return render(request, 'payments/paypal_checkout.html', {'form': form, 'cart': cart})
                elif payment_provider == 'pesapal':
                    pesapal_data = initiate_pesapal_payment(request, cart, delivery_info, total_usd)
                    if pesapal_data.get('status') == 'down':
                        messages.warning(request, pesapal_data['message'])
                        return render(request, 'payments/checkout.html', context)
                    return render(request, 'payments/pesapal_checkout.html', {
                        'iframe_url': pesapal_data['iframe_url'],
                        'cart': cart,
                        'order_id': pesapal_data['order_id'],
                        'total_usd': total_usd,
                    })
                elif payment_provider == 'stripe':
                    stripe_data = initiate_stripe_payment(request, cart, delivery_info, total_usd)
                    request.session['stripe_session_id'] = stripe_data['session_id']
                    return render(request, 'payments/stripe_checkout.html', stripe_data)
            except Exception as e:
                messages.error(request, f"{payment_provider.title()} payment initiation failed: {str(e)}")
                return render(request, 'payments/checkout.html', context)

        # Handle mobile money payments
        elif payment_method == 'mobile_money':
            try:
                if payment_provider == 'airtel':
                    data = initiate_airtel_payment(request, cart, delivery_info, total_zmw)
                elif payment_provider == 'zamtel':
                    data = initiate_zamtel_payment(request, cart, delivery_info, total_zmw)
                elif payment_provider == 'mtn':
                    data = initiate_mtn_payment(request, cart, delivery_info, total_zmw, phone_number)

                if data['status'] == 'success':
                    messages.info(request, data['message'])
                    request.session['delivery_id'] = delivery_info.id
                    template_map = {
                        'airtel': 'payments/airtel_checkout.html',
                        'zamtel': 'payments/zamtel_checkout.html',
                        'mtn': 'payments/mtn_checkout.html',
                    }
                    return render(request, template_map[payment_provider], {
                        'phone_number': phone_number,
                        'secondary_phone_number': secondary_phone_number,
                        'total_zmw': total_zmw,
                        'transaction_id': data.get('transaction_id'),
                        'delivery_id': delivery_info.id,
                    })
                else:
                    messages.warning(request, data.get('message', f"{payment_provider.upper()} payment failed."))
            except Exception as e:
                messages.error(request, f"{payment_provider.title()} payment failed: {str(e)}")
            return render(request, 'payments/checkout.html', context)

        # Cash payment
        messages.success(request, "Your cash order has been placed successfully.")
        return redirect('payments:payment_success', delivery_id=delivery_info.id)

    return render(request, 'payments/checkout.html', context)

# Payment processing views for Airtel, Zamtel, MTN
@login_required
@csrf_exempt
def simulate_mobile_payment(request, provider):
    if request.method != 'POST':
        return redirect('payments:checkout')

    phone = request.POST.get('phone') or request.POST.get('mtn_number')
    amount = request.POST.get('amount')
    delivery_id = request.session.get('delivery_id')

    if not delivery_id:
        messages.error(request, "Invalid session. Please try again.")
        logger.warning(f"{provider.upper()} payment attempted with no delivery_id in session")
        return redirect('payments:checkout')

    try:
        delivery_info = DeliveryInfo.objects.get(id=delivery_id, user=request.user)
        if delivery_info.delivery_status != 'pending':
            messages.error(request, f"Order is already {delivery_info.get_delivery_status_display()}.")
            return redirect('payments:payment_success', delivery_id=delivery_id)

        logger.info(f" {provider.title()} payment for {phone}, Amount: {amount} ZMW, Delivery {delivery_id}")
        messages.success(request, f"{provider.title()} payment  successfully!")
        return redirect('payments:payment_success', delivery_id=delivery_id)

    except DeliveryInfo.DoesNotExist:
        messages.error(request, "Order not found.")
        return redirect('payments:checkout')
    except Exception as e:
        logger.error(f"{provider.title()} payment processing failed: {str(e)}")
        messages.error(request, f"Payment processing failed: {str(e)}")
        return redirect('payments:checkout')

# Aliases for each provider
airtel_payment_process = lambda request: simulate_mobile_payment(request, 'airtel')
zamtel_payment_process = lambda request: simulate_mobile_payment(request, 'zamtel')
mtn_payment_process = lambda request: simulate_mobile_payment(request, 'mtn')

from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import get_object_or_404, redirect, render
from django.contrib import messages
import logging

from .models import DeliveryInfo, PaymentHistory
from staffs.models import StaffAssignment, Notification

logger = logging.getLogger(__name__)

@login_required
@csrf_exempt
def payment_success(request, delivery_id):
    delivery_info = get_object_or_404(DeliveryInfo, id=delivery_id, user=request.user)
    cart = delivery_info.cart
    payment_history = PaymentHistory.objects.filter(delivery_info=delivery_info).first()

    if request.method == 'POST' and delivery_info.delivery_status == 'in_progress':
        try:
            if not payment_history:
                items = [{
                    "name": item.get_product().name,
                    "quantity": item.quantity,
                    "subtotal": float(item.subtotal())
                } for item in cart.cartitem_set.all()]

                payment_history = PaymentHistory.objects.create(
                    user=request.user,
                    cart=cart,
                    delivery_info=delivery_info,
                    total=cart.total(),
                    items=items
                )

            delivery_info.delivery_status = 'completed'
            delivery_info.save()

            staff_assignment = StaffAssignment.objects.filter(delivery=delivery_info).first()
            if staff_assignment:
                Notification.objects.create(
                    recipient=staff_assignment.staff,
                    message=f"Delivery at {delivery_info.get_predefined_address_display()} confirmed by customer.",
                    related_delivery=delivery_info,
                    notification_type='delivery_completed'
                )

            cart.cartitem_set.all().delete()
            for key in ['mtn_transaction_id', 'delivery_id', 'stripe_session_id', 'paypal_delivery_id']:
                request.session.pop(key, None)

            sms_body = (
                f"Order #{payment_history.id} Confirmed!\n"
                f"Total: K{cart.total():.2f}\n"
                f"Delivery to: {delivery_info.address or delivery_info.get_predefined_address_display()}\n"
                f"Thank you for ordering with us!"
            )

            # === MOCK SMS MESSAGE ===
            messages.success(request, f"Order confirmed! (SMS would be sent to {delivery_info.phone_number})")

            return redirect('payments:payment_success', delivery_id=delivery_id)

        except Exception as e:
            logger.error(f"Error confirming delivery {delivery_id}: {str(e)}")
            messages.error(request, f"An error occurred: {str(e)}")

    # Add pending status for PayPal if payment is not yet confirmed
    context = {
        'delivery_info': delivery_info,
        'cart': cart,
        'payment_history': payment_history,
        'is_pending': delivery_info.payment_method == 'card' and delivery_info.payment_provider == 'paypal' and not payment_history,
    }

    return render(request, 'payments/success.html', context)
@login_required
@csrf_exempt
def payment_done(request):
    session_id = request.session.get('stripe_session_id')
    if not session_id:
        messages.error(request, "Invalid payment session.")
        return redirect('payments:checkout')

    try:
        status = verify_stripe_payment(session_id)
        if status == 'paid':
            delivery_info = DeliveryInfo.objects.filter(user=request.user).latest('created_at')
            del request.session['stripe_session_id']
            messages.success(request, "Payment successful!")
            return redirect('payments:payment_success', delivery_id=delivery_info.id)
        else:
            messages.error(request, "Payment was not completed.")
    except Exception as e:
        messages.error(request, f"Payment verification failed: {str(e)}")
    return redirect('payments:checkout')

@login_required
def payment_cancelled(request):
    messages.error(request, "Payment was cancelled.")
    return redirect('payments:checkout')

@login_required
def order_history(request):
    history = PaymentHistory.objects.filter(user=request.user)
    return render(request, 'payments/order_history.html', {'history': history})

@login_required
def reorder(request, payment_id):
    if request.method != 'POST':
        return redirect('payments:order_history')

    payment_history = get_object_or_404(PaymentHistory, id=payment_id, user=request.user)
    cart, _ = Cart.objects.get_or_create(user=request.user)
    cart.cartitem_set.all().delete()

    for item in payment_history.items:
        for model in [FastFood, Food, Drink]:
            try:
                product = model.objects.get(name=item['name'])
                model_field = 'fast_food' if model.__name__ == 'FastFood' else model.__name__.lower()
                CartItem.objects.create(cart=cart, **{model_field: product}, quantity=item['quantity'], quality='standard')
                break
            except model.DoesNotExist:
                continue
        else:
            messages.warning(request, f"Product '{item['name']}' is no longer available.")

    messages.success(request, "Order has been added to your cart!")
    return redirect('cart:cart_view')

@csrf_exempt
def mtn_callback(request):
    if request.method == 'PUT':
        try:
            data = request.body.decode('utf-8')
            logger.info(f"MTN Callback received: {data}")
            # TODO: handle callback data
            return HttpResponse(status=200)
        except Exception as e:
            logger.error(f"MTN Callback error: {str(e)}")
            return HttpResponse(status=500)
    return HttpResponse(status=405)
yes and  from paypal.standard.ipn.signals import valid_ipn_received
from django.dispatch import receiver
from .models import DeliveryInfo, PaymentHistory
from cart.models import Cart
# /home/surecode/Documents/GitHub/django/eatnearby/payments/signals.py
@receiver(valid_ipn_received)
def paypal_payment_received(sender, **kwargs):
    ipn_obj = sender
    if ipn_obj.payment_status == 'Completed':
        delivery_id = ipn_obj.custom  # DeliveryInfo ID passed in 'custom'
        try:
            delivery_info = DeliveryInfo.objects.get(id=delivery_id)
            cart = delivery_info.cart

            items = [
                {"name": item.get_product().name, "quantity": item.quantity, "subtotal": float(item.subtotal())}
                for item in cart.cartitem_set.all()
            ]
            payment_history = PaymentHistory(
                user=delivery_info.user,
                cart=cart,
                delivery_info=delivery_info,
                total=cart.total(),
                items=items,
                transaction_id=ipn_obj.txn_id
            )
            payment_history.save()

            delivery_info.delivery_status = 'completed'
            delivery_info.save()
            cart.cartitem_set.all().delete()
        except DeliveryInfo.DoesNotExist:
            # Log error or notify admin if needed
            pass    # payments/models.py
from django.db import models
from auths.models import User
from cart.models import Cart
import logging

logger = logging.getLogger(__name__)

class DeliveryInfo(models.Model):
    id = models.BigAutoField(primary_key=True)

    DELIVERY_POINTS = [
        ('evelyhone', 'Evelyn Hone College'),
        ('zambia_police', 'Zambia Police Headquarters'),
        ('zambia_accountancy', 'Zambia Centre for Accountancy'),
        ('mukuba_house', 'Mukuba Pension House'),
        ('bus_terminus', 'Lusaka Intercity Bus Terminus'),
        ('national_museum', 'Lusaka National Museum'),
    ]

    PAYMENT_METHODS = [
        ('cash', 'Cash'),
        ('mobile_money', 'Mobile Money'),
        ('card', 'Card'),
    ]

    MOBILE_MONEY_PROVIDERS = [
        ('airtel', 'Airtel'),
        ('mtn', 'MTN'),
        ('zamtel', 'Zamtel'),
    ]

    CARD_PROVIDERS = [
        ('paypal', 'Paypal'),
        ('pesapal', 'Pesapal'),
        ('stripe', 'Stripe'),
    ]

    DELIVERY_STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('cancelled', 'Cancelled'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    address = models.CharField(max_length=100, blank=True, null=True)
    predefined_address = models.CharField(
        max_length=30,
        choices=DELIVERY_POINTS,
        blank=True,
        null=True,
        help_text="Predefined delivery point"
    )
    delivery_status = models.CharField(
        max_length=20,
        choices=DELIVERY_STATUS_CHOICES,
        default='pending',
        help_text="Current delivery status"
    )
    payment_method = models.CharField(
        max_length=20,
        choices=PAYMENT_METHODS,
        default='cash',
        help_text="Payment method used"
    )
    payment_provider = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        help_text="Specific provider for Mobile Money or Card (e.g., Airtel, Stripe)"
    )
    phone_number = models.CharField(max_length=20)
    secondary_phone_number = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        help_text="Optional secondary contact number"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def save(self, *args, **kwargs):
        if self.pk:
            try:
                old_instance = DeliveryInfo.objects.get(pk=self.pk)
                if old_instance.delivery_status != self.delivery_status:
                    logger.info(
                        f"DeliveryInfo {self.id} status changed from "
                        f"{old_instance.delivery_status} to {self.delivery_status}"
                    )
            except DeliveryInfo.DoesNotExist:
                logger.warning(f"DeliveryInfo {self.id} not found during save")
        else:
            logger.info(f"New DeliveryInfo created with status {self.delivery_status}")
        if self.predefined_address and not self.address:
            self.address = self.get_predefined_address_display()
        super().save(*args, **kwargs)

    def __str__(self):
        address_display = self.address or self.get_predefined_address_display() or "N/A"
        return f"Delivery for {self.user.username} at {address_display}"

    class Meta:
        ordering = ['-created_at']
        verbose_name = "Delivery Info"
        verbose_name_plural = "Delivery Info"


class PaymentHistory(models.Model):
    id = models.BigAutoField(primary_key=True)
    transaction_id = models.CharField(max_length=100, blank=True, null=True)  # paypal transaction
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    cart = models.ForeignKey(Cart, on_delete=models.SET_NULL, null=True)
    delivery_info = models.ForeignKey(
        DeliveryInfo,
        on_delete=models.SET_NULL,
        null=True,
        related_name='payment_histories'
    )
    total = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)
    items = models.JSONField(
        help_text="List of items in the payment (e.g., [{'name': 'Pizza', 'quantity': 2, 'subtotal': 15.00}])"
    )

    def __str__(self):
        return f"Payment by {self.user.username} on {self.created_at}"

    class Meta:
        ordering = ['-created_at']
        verbose_name = "Payment History"
        verbose_name_plural = "Payment Histories"  # payments/apps.py
from django.apps import AppConfig

class PaymentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'payments'

    def ready(self): 
        import payments.signals   and settings i have 
#  paypay settings
PAYPAL_TEST = True
PAYPAL_RECEIVER_EMAIL = 'eatnearby@gmail.com'


PAYPAL_BUY_BUTTON_IMAGE = 'https://www.paypalobjects.com/webstatic/en_US/i/buttons/checkout-logo-large.png'
PAYPAL_IDENTITY_TOKEN = 'your_sandbox_identity_token'  # Optional, for PDT if needed
 
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'sim',
    'auths',
    'cart',
 
    'payments.apps.PaymentsConfig',
    'paypal.standard.ipn',
    'pwa',
    'staffs.apps.StaffsConfig',    
lets fix so done touch other paymnets configs  like stripe and pesapay or  all mobile mobile or cash    ...... fix paypal invaild session error only




and the staffs views 
from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_POST
from django.utils.timezone import now
from django.core.paginator import Paginator
from django.db.models import Count, Q
from django.contrib import messages
from payments.models import DeliveryInfo
from .models import StaffAssignment, Notification
from .staffs_decorator import staff_view
from payments.models import PaymentHistory
from django.contrib.auth import get_user_model
import logging

User = get_user_model()
logger = logging.getLogger(__name__)

# ========== Dashboard ==========
@login_required
@staff_view
def dashboard(request):
    today = now().date()
    staff = request.user

    stats = StaffAssignment.objects.filter(staff=staff).aggregate(
        active_count=Count('id', filter=Q(delivery__delivery_status='in_progress')),
        completed_today_count=Count('id', filter=Q(delivery__delivery_status='completed', delivery__updated_at__date=today)),
        total_completed_count=Count('id', filter=Q(delivery__delivery_status='completed')),
        pending_count=Count('id', filter=Q(delivery__delivery_status='pending'))
    )

    active_deliveries = stats['active_count']
    completed_today = stats['completed_today_count']
    total_completed = stats['total_completed_count']
    pending_count = stats['pending_count']
    on_time_rate = 0 if total_completed == 0 else round((completed_today / total_completed) * 100)

    payment_history = PaymentHistory.objects.filter(
        delivery_info__staff_assignments__staff=staff
    ).select_related('delivery_info').order_by('-created_at')

    paginator = Paginator(payment_history, 10)
    page_number = request.GET.get('page', 1)
    page_obj = paginator.get_page(page_number)

    context = {
        'my_deliveries': {
            'active_count': active_deliveries,
            'completed_today': completed_today,
            'on_time_rate': on_time_rate,
            'pending_count': pending_count
        },
        'payment_history': page_obj,
        'page_obj': page_obj
    }
    return render(request, 'staffs/dashboard.html', context)

# ========== My Deliveries ==========
@login_required
@staff_view
def my_deliveries(request):
    today = now().date()
    staff = request.user

    stats = StaffAssignment.objects.filter(staff=staff).aggregate(
        active_count=Count('id', filter=Q(delivery__delivery_status='in_progress')),
        completed_today_count=Count('id', filter=Q(delivery__delivery_status='completed', delivery__updated_at__date=today)),
        total_completed_count=Count('id', filter=Q(delivery__delivery_status='completed')),
        pending_count=Count('id', filter=Q(delivery__delivery_status='pending'))
    )

    # Fetch pending deliveries assigned to the staff
    pending_deliveries = DeliveryInfo.objects.filter(
        staff_assignments__staff=staff,
        delivery_status='pending'
    ).select_related('user', 'cart').order_by('-created_at')

    # Fetch in-progress deliveries
    in_progress_deliveries = DeliveryInfo.objects.filter(
        staff_assignments__staff=staff,
        delivery_status='in_progress'
    ).select_related('user', 'cart').order_by('-created_at')

    context = {
        'my_deliveries': {
            'active_count': stats['active_count'],
            'completed_today': stats['completed_today_count'],
            'on_time_rate': 0 if stats['total_completed_count'] == 0 else round((stats['completed_today_count'] / stats['total_completed_count']) * 100),
            'pending_count': stats['pending_count']
        },
        'pending_deliveries': pending_deliveries,
        'in_progress_deliveries': in_progress_deliveries
    }
    return render(request, 'staffs/my_deliveries.html', context)

# ========== Delivery History ==========
@login_required
@staff_view
def delivery_history(request):
    staff = request.user
    deliveries = DeliveryInfo.objects.filter(
        staff_assignments__staff=staff
    ).select_related('user').order_by('-updated_at')

    notifications = Notification.objects.filter(
        recipient=staff,
        is_read=False
    ).order_by('-created_at')[:10]
    logger.debug(f"Notifications for user {staff.id}: {[n.id for n in notifications]}")

    context = {
        'deliveries': deliveries,
        'notifications': notifications
    }
    return render(request, 'staffs/delivery_history.html', context)

# ========== Accept Delivery ==========
@login_required
@require_POST
def accept_delivery(request, delivery_id):
    delivery = get_object_or_404(DeliveryInfo, id=delivery_id)
    if delivery.delivery_status != 'pending':
        messages.warning(request, "This delivery has already been accepted or processed.")
        return redirect('staffs:my_deliveries')
    assignment = StaffAssignment.objects.filter(staff=request.user, delivery=delivery).first()
    if not assignment:
        messages.error(request, "You are not assigned to this delivery.")
        return redirect('staffs:my_deliveries')
    try:
        delivery.delivery_status = 'in_progress'
        delivery.save()
        messages.success(request, "Delivery accepted and is now in progress.")
        logger.info(f"Delivery {delivery_id} accepted by user {request.user.id}, status updated to in_progress")
        # ... (notifications and SMS)
    except Exception as e:
        messages.error(request, f"An error occurred: {str(e)}")
    return redirect('staffs:my_deliveries')

# ========== Decline Delivery ==========
@login_required
@require_POST
def decline_delivery(request, delivery_id):
    delivery = get_object_or_404(DeliveryInfo, id=delivery_id)
    logger.info(f"User {request.user.id} attempting to decline delivery {delivery_id}, current status: {delivery.delivery_status}")

    if delivery.delivery_status == 'pending':
        delivery.delivery_status = 'cancelled'
        delivery.save()
        messages.info(request, "You declined the delivery.")
        logger.info(f"Delivery {delivery_id} declined by user {request.user.id}, status updated to cancelled")

        Notification.objects.create(
            recipient=request.user,
            message=f"You declined delivery (Order ID: {delivery.id})",
            related_delivery=delivery,
            notification_type='delivery_declined'
        )
    else:
        messages.warning(request, "This delivery cannot be declined as it is no longer pending.")
        logger.warning(f"Delivery {delivery_id} is not pending, status: {delivery.delivery_status}")

    return redirect('staffs:my_deliveries')

# ========== Availability ==========
@login_required
@staff_view
def availability(request, staff_id=None):
    today = now().date()

    def get_user_status(user):
        if StaffAssignment.objects.filter(staff=user, delivery__created_at__date=today).exists():
            return 'delivering'
        elif user.last_login and user.last_login.date() == today:
            return 'present'
        return 'not at work'

    if staff_id:
        staff = get_object_or_404(User, id=staff_id)
        if not (request.user.user_type in ['staff', 'admin'] or request.user.is_superuser):
            return render(request, 'staffs/error.html', {'message': 'You do not have permission to view this page.'})
        staff.status = get_user_status(staff)
        staff.role = getattr(staff, 'get_user_type_display', lambda: 'Staff')()
        return render(request, 'staffs/availability_single.html', {'staff': staff})

    if not (request.user.user_type in ['staff', 'admin'] or request.user.is_superuser):
        return render(request, 'staffs/error.html', {'message': 'You do not have permission to view this page.'})

    staff_list = User.objects.filter(user_type='staff')
    for staff in staff_list:
        staff.status = get_user_status(staff)
        staff.role = getattr(staff, 'get_user_type_display', lambda: 'Staff')()

    return render(request, 'staffs/availability.html', {'staff_list': staff_list})

# ========== Profile ==========
@login_required
@staff_view
def profile(request):
    return render(request, 'staffs/profile.html')

# ========== Settings ==========
@login_required
@staff_view
def settings(request):
    return render(request, 'staffs/settings.html')

# ========== Notifications API ==========
@login_required
@staff_view
def get_unread_notifications(request):
    unread = Notification.objects.filter(recipient=request.user, is_read=False).order_by('-created_at')
    notifications_data = [{
        'id': n.id,
        'message': n.message,
        'type': n.notification_type,
        'created_at': n.created_at.strftime('%Y-%m-%d %H:%M:%S'),
        'delivery_id': n.related_delivery.id if n.related_delivery else None,
    } for n in unread]
    return JsonResponse({'notifications': notifications_data})

@login_required
@staff_view
@require_POST
def delete_notification(request, notification_id):
    notification = get_object_or_404(Notification, id=notification_id, recipient=request.user)
    if request.method == 'POST':
        notification.delete()
        return redirect('staffs:delivery_history')
    return redirect('staffs:delivery_history')

@login_required
@staff_view
@require_POST
def mark_notification_read(request, notification_id):
    notification = get_object_or_404(Notification, id=notification_id, recipient=request.user)
    notification.is_read = True
    notification.save()
    return JsonResponse({'status': 'success'})

@login_required
@staff_view
@require_POST
def mark_all_notifications_read(request):
    Notification.objects.filter(recipient=request.user, is_read=False).update(is_read=True)
    return JsonResponse({'status': 'success'})